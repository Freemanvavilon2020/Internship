## Что нового узнал 
Функции, Аргументы функции, Классы, Свойства, Магические методы, Абстрактные классы, Интерфейсы, Трэйт


### Homework


# PHP 

[Функции ](https://www.php.net/manual/ru/language.functions.php)

[Стандартные функции PHP](http://www.php.su/functions/?page=standard)

[Пользовательские функции в PHP](http://www.php.su/functions/custom/)

[Классы и объекты](https://www.php.net/manual/ru/language.oop5.php)


### Магические методы
>Магические методы - это специальные методы, которые переопределяют действие PHP по умолчанию, когда над объектом выполняются определённые действия.подробнее смотри [тут](https://www.php.net/manual/ru/language.oop5.magic.php)

Следующие названия методов считаются магическими:
 * __construct(), 
 * __destruct(), 
 * __call(), 
 * __callStatic(), 
 * __get(), 
 * __set(), 
 * __isset(), 
 * __unset(), 
 * __sleep(), 
 * __wakeup(), 
 * __serialize(), 
 * __unserialize(), 
 * __toString(),
 * __invoke(), 
 * __set_state(), 
 * __clone() 
 * __debugInfo()

___

### Абстрактные классы 
PHP поддерживает определение абстрактных классов и методов. На основе абстрактного класса нельзя создавать объекты, и любой класс, содержащий хотя бы один абстрактный метод, должен быть определён как абстрактный. Методы, объявленные абстрактными, несут, по существу, лишь описательный смысл и не могут включать реализацию.

При наследовании от абстрактного класса, все методы, помеченные абстрактными в родительском классе, должны быть определены в дочернем классе и следовать обычным правилам наследования и совместимости сигнатуры.подробнее смотри [тут](https://www.php.net/manual/ru/language.oop5.abstract.php)
___


### Интерфейсы

Интерфейсы объектов позволяют создавать код, который указывает, какие методы должен реализовать класс, без необходимости определять, как именно они должны быть реализованы. Интерфейсы разделяют пространство имён с классами и трейтами, поэтому они не могут называться одинаково.

Интерфейсы объявляются так же, как и обычные классы, но с использованием ключевого слова interface вместо class. Тела методов интерфейсов должны быть пустыми.

Все методы, определённые в интерфейсах, должны быть общедоступными, что следует из самой природы интерфейса.

На практике интерфейсы используются в двух взаимодополняющих случаях:

 * Чтобы позволить разработчикам создавать объекты разных классов, которые могут использоваться взаимозаменяемо, поскольку они реализуют один и тот же интерфейс или интерфейсы. Типичный пример - несколько служб доступа к базе данных, несколько платёжных шлюзов или разных стратегий кеширования. Различные реализации могут быть заменены без каких-либо изменений в коде, который их использует.
 * Чтобы разрешить функции или методу принимать и оперировать параметром, который соответствует интерфейсу, не заботясь о том, что ещё может делать объект или как он реализован. Эти интерфейсы часто называют Iterable, Cacheable, Renderable и так далее, чтобы описать их поведение.
Интерфейсы могут определять магические методы, требуя от реализующих классов реализации этих методов.

## Замечание:

Хотя они поддерживаются, использование конструкторов в интерфейсах настоятельно не рекомендуется. Это значительно снижает гибкость объекта, реализующего интерфейс. Кроме того, к конструкторам не применяются правила наследования, что может привести к противоречивому и неожиданному поведению.

>implements 
Для реализации интерфейса используется оператор implements. Класс должен реализовать все методы, описанные в интерфейсе, иначе произойдёт фатальная ошибка. При желании классы могут реализовывать более одного интерфейса, разделяя каждый интерфейс запятой.

## Внимание
Класс может реализовать два интерфейса, которые определяют метод с тем же именем, только если объявление метода в обоих интерфейсах идентично.

## Внимание
Класс, реализующий интерфейс, может использовать для своих параметров имя, отличное от имени интерфейса. Однако, начиная с PHP 8.0, в языке поддерживаются именованные аргументы, и вызывающий код может полагаться на имя параметра в интерфейсе. По этой причине настоятельно рекомендуется, чтобы разработчики использовали те же имена параметров, что и реализуемый интерфейс.

## Замечание:

Интерфейсы могут быть унаследованы друг от друга, так же, как и классы, с помощью оператора extends.

## Замечание:

Класс, реализующий интерфейс, должен объявить все методы в интерфейсе с совместимой сигнатурой.

Константы (Constants) 
Интерфейсы могут содержать константы. Константы интерфейсов работают точно так же, как и константы классов, за исключением того, что они не могут быть переопределены наследующим классом или интерфейсом.
Более подробная информация [тут](https://www.php.net/manual/ru/language.oop5.interfaces.php)
___
### Трейты

PHP реализует метод для повторного использования кода под названием трейт (trait).

>Трейт - это механизм обеспечения повторного использования кода в языках с поддержкой только одиночного наследования, таких как PHP. Трейт предназначен для уменьшения некоторых ограничений одиночного наследования, позволяя разработчику повторно использовать наборы методов свободно, в нескольких независимых классах и реализованных с использованием разных архитектур построения классов. Семантика комбинации трейтов и классов определена таким образом, чтобы снизить уровень сложности, а также избежать типичных проблем, связанных с множественным наследованием и смешиванием (mixins).

Трейт очень похож на класс, но предназначен для группирования функционала хорошо структурированным и последовательным образом. Невозможно создать самостоятельный экземпляр трейта. Это дополнение к обычному наследованию и позволяет сделать горизонтальную композицию поведения, то есть применение членов класса без необходимости наследования.Подробнее [тут](https://www.php.net/manual/ru/language.oop5.traits.php)


# JS 
Методы жизненного цикла React.Js

### Полезные материалы
[Жизненый цикл компонента](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

[React.Component](https://ru.reactjs.org/docs/react-component.html)

Практический пример находиться в папке 40 урока

